# Списки (List)

Линейные структуры с произвольным доступом к элементам через итераторы.

## Функциональная спецификация двусвязного списка

**Определение:** Последовательность элементов с двунаправленной связью, позволяющая эффективную вставку и удаление в любой позиции.

### Операции

```
init         - инициализация
is_empty     - проверка на пустоту
size         - получение размера
first        - первый элемент
last         - последний элемент
next         - следующий элемент (итератор)
prev         - предыдущий элемент (итератор)
insert       - добавить элемент
remove       - удалить элемент
destroy      - уничтожить список
```

### Свойства списка

Образно говоря, проверка структуры на право называться списком:

1. `is_empty(init(list)) = true` - инициализация создаёт пустой список
2. `is_empty(add(list, a)) = false` - добавление элемента → список не пуст
3. `prev(next(t)) = t` - предыдущий от следующего = текущий
4. `next(prev(t)) = t` - следующий от предыдущего = текущий
5. **Пример работы:**
   ```
   list = init()
   list = add(list, t2, t2)
   list = add(list, t2, t1)
   first(list) = t1
   last(list) = t2
   ```
   Читаем слева направо.

## Файлы

- **`lst_dyn.c`** - Двусвязный список (malloc/free)
  - O(1) вставка/удаление в любом месте
  - Итераторы для навигации
  - Стандартная реализация с динамической памятью

- **`lst_vct.c`** - Список на векторе (пул элементов)
  - O(1) операции без malloc
  - Фиксированный пул элементов
  - Быстрее за счёт locality of reference

## Операции

| Операция | Описание | Сложность |
|----------|----------|-----------|
| `insert` | Вставка по итератору | O(1) |
| `erase` | Удаление по итератору | O(1) |
| `push_front/back` | Добавить в начало/конец | O(1) |
| `pop_front/back` | Удалить из начала/конца | O(1) |

## Особенности

**Двусвязный список:**
- Итерация в обе стороны
- Удаление без поиска (если есть итератор)
- Больше памяти на элемент (два указателя)

**Список vs Вектор:**
- Список: O(1) вставка/удаление, O(n) доступ по индексу
- Вектор: O(n) вставка/удаление, O(1) доступ по индексу

## Применение

- Когда много вставок/удалений в середине
- LRU кэш (с хэш-таблицей)
- Списки смежности графов
- Когда нужна стабильность итераторов

