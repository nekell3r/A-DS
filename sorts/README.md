# Сортировка

## Введение

Сортировка представляет собой хороший пример задачи, для решения которой существует множество различных алгоритмов. Каждый из них имеет свои достоинства и свои недостатки, и выбор нужного алгоритма зависит от многих конкретных условий.

Сортировку следует понимать как процесс перестановки заданного множества объектов в некотором порядке. **Цель сортировки** — облегчить последующий поиск элементов в таком отсортированном множестве. Сортировка — это один из универсальных основополагающих видов обработки данных. Телефонные книги, словари, оглавления библиотек, прайс-листы — вот примеры отсортированных для поиска множеств хранимых объектов.

## Основные понятия

### Определение сортировки

Сортируемые элементы будем обозначать \(a_1, a_2, \ldots, a_n\). Сортировка есть некоторая перестановка этих элементов \(a_{k_1}, a_{k_2}, \ldots, a_{k_n}\), где \((k_1, k_2, \ldots, k_n\) — перестановка последовательности \(1, 2, \ldots, n)\), для которой выполнено некоторое отношение порядка \(f\):

$$f(a_{k_1}) \leq f(a_{k_2}) \leq \ldots \leq f(a_{k_n})$$

### Ключи

В случае, когда элементы \(a_1, a_2, \ldots, a_n\) непосредственно сравнимы, отношение порядка \(f\) вычислять не требуется, а достаточно хранить сами сравниваемые компоненты в соответствующих полях элементов \(a_i\). Сравниваемые поля элементов сортировки называются **ключами**. Типы других компонент элементов, хранимых с ключами, могут быть самыми разнообразными, и поэтому элементы обычно имеют комбинированный тип:

```c
typedef struct
{
    int key;
    /* описание других компонент */
} Item;
```

Итак, ключ идентифицирует каждый элемент множества и определяет его итоговое местоположение в упорядочиваемой последовательности. Для исследования алгоритмов сортировки существенен только ключ. Для простоты мы будем полагать ключ скалярным и, без ограничения общности, целочисленным.

## Классификация методов сортировки

### Внутренняя и внешняя сортировка

Выбор алгоритма всегда зависит от структуры обрабатываемых данных. В случае сортировки эта зависимость столь глубока, что соответствующие методы распадаются на два почти непересекающихся класса — **сортировку массивов** и **сортировку файлов (последовательностей)**. Иногда их называют **внутренними** и **внешними** сортировками.

### Устойчивая сортировка

Метод сортировки называется **устойчивым (стабильным)**, если в процессе сортировки относительное расположение элементов с равными ключами не изменяется. Устойчивость сортировки полезна, когда предполагается последующее упорядочивание по вторичным ключам среди равнозначных элементов.

### Естественная сортировка

Метод сортировки называется **естественным**, если в процессе сортировки учитывается частичная или полная упорядоченность элементов сортируемого множества.

Методы сортировки также могут быть классифицированы по использованию сравнений сортируемых элементов.

## Оценка эффективности сортировки

При оценке эффективности сортировки, количество сравнений и перестановок рассматривается отдельно, поскольку их цена может значительно отличаться (перестановки, обычно, дороже, хотя, например, при сортировке строк перестановки дешевые - обмен указателей, а сравнение - дорогое: лексикографическое за O(n)).

### Сравнение прямых методов сортировки

Прямые методы сортировки имеют точные оценки:

| | | Минимум | Среднее | Максимум |
|---------|-------------------|---------|---------|---------|
| **Вставка** | Сравнений (C) | n - 1 | (n² + n - 2) / 4 - 1 | (n² - n) / 2 |
| | Присваиваний (M) | 2(n - 1) | (n² - 9n - 10) / 4 | (n² - 3n - 4) / 2 |
| **Выборка** | Сравнений | (n² - n) / 2 | (n² - n) / 2 | (n² - n) / 2 |

### Усовершенствованные методы

Усовершенствованные методы не имеют сколько-нибудь простых и точных формул сложностной оценки. Для сортировки Шелла затраты составляют O(n^(1+δ)), а для пирамидальной и быстрой — O(n log n). Эти оценки позволяют разбить все сортировки на примитивные, прямые, квадратичные методы со сложностью O(n²) и улучшенные или линеаримфические O(n log n).

### Дополнительные методы сравнения

| | | Минимум | Среднее | Максимум |
|---------|-------------------|---------|---------|---------|
| | Присваиваний | 3(n - 1) | n(ln n + 0,57) | (n² / 4) + 3(n - 1) |
| **Пузырьковая** | Сравнений | (n² - n) / 2 | (n² - n) / 2 | (n² - n) / 2 |
| | Присваиваний | 0 | 3(n² - n) / 4 | 3(n² - n) / 2 |

## Экспериментальные результаты

Поскольку получить точные оценки для всех сортировок затруднительно, представляют интерес результаты вычислительного эксперимента, проведенного Н. Виртом на микроЭВМ Lilith с микропрограммной поддержкой языка Модула 2 (M-код) для массива данных из 2048 элементов со **скалярным** ключом:

| Сортировка | Упорядоченный | Случайный | Обратный порядок |
|------------|---------------|-----------|------------------|
| Вставка | 0,22 | 50,74 | 103,80 |
| Двоичная вставка | 1,16 | 37,66 | 76,06 |
| Выборка | 58,18 | 58,34 | 73,46 |
| Пузырьковая | 80,18 | 128,84 | 178,66 |
| Шейкерная | 0,16 | 104,44 | 187,36 |
| Шелла | 0,80 | 7,08 | 12,34 |
| Пирамидальная | 2,32 | 2,22 | 2,12 |
| *Гладкая* | 0,22? | 2,22? | 2,12? |
| Быстрая | 0,72 | 1,22 | 0,76 |
| Быстрая перекурс. | 0,72 | 1,32 | 0,80 |
| Слияние | 1,98 | 2,06 | 1,98 |

### Выводы из эксперимента

Времена, приведенные в этой таблице, во-первых, свидетельствуют о колоссальной разнице квадратичных и линеаримфических методов уже на массиве из 2048 элементов (а это всего выпускник крупного вуза!). Во-вторых:

- **Двоичная вставка** по сравнению с простой почти ничего не дает, а в случае упорядоченного массива даже получается отрицательный эффект;

- **Пузырьковая сортировка** определенно наихудшая из всех сравниваемых, ее усовершенствованная шейкерная версия все равно проигрывает почти всем методам;

- **Быстрая сортировка** в 2–3 раза лучше пирамидальной, но уступает ее гладкой разновидности на почти упорядоченных последовательностях.

### Сравнение гладкой и быстрой сортировки

Количество элементов 2048 (2¹¹):

| | Упорядоченный | Случайный | Обратный порядок |
|---------|--------------|-----------|------------------|
| Гладкая | 20,451 | 110,252 | 92,751 |
| Быстрая | 22,542 | 38,125 | 23,579 |

Количество элементов 1 048 576 (2²⁰):

| | Упорядоченный | Случайный | Обратный порядок |
|---------|--------------|-----------|------------------|
| Гладкая | 10,485,713 | 108,745,438 | 78,519,838 |
| Быстрая | 20,971,543 | 32,394,581 | 21,495,853 |

Как и ожидалось, гладкая сортировка быстрее быстрой на упорядоченном наборе, особенно при его больших размерах. Как и всякая пирамидальная, гладкая сортировка проигрывает быстрой на случайном наборе. А на обратном порядке быстрая сортировка вне конкуренции, поскольку гладкая сортировка не обладает естественностью к обратному порядку элементов.

## Практические рекомендации

При выборе сортировки следует учитывать:

1. **Цены на сравнение и перестановки** сортируемого типа
2. **Способ доступа к сортируемым элементам** (если последовательный - можно задуматься над слиянием)
3. **Особенности данных**: для специфических наборов данных, при разделении массива может иметь место явный перекос одного из подмассивов по размеру. В этом случае к сортировке большого подмассива стоит подключить пирамиду (опять же, передаем привет STL)

Также не стоит так уж боготворить сортировку Хоара (не спорю, она крутая): на специфических наборах данных, при разделении массива может иметь место явный перекос одного из подмассивов по размеру.

В реальных случаях на коэффициенты этих оценок могут влиять архитектурные факторы (ускорение пересылок и/или сравнений аппаратными средствами либо оптимизирующими компиляторами) и форма и местонахождение (резидентные, ...) ключей (простые или составные) или самих данных. Иногда ключи размещают в оперативной памяти, а данные остаются на внешней памяти, и, следовательно, раздельное сравнение сравнений и присваиваний актуально.

