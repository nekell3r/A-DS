// Сортировка вставками (Insertion Sort)
// Элементы вставляются в отсортированную часть массива

// Сортировка вставками
void insertion_sort(int arr[], int n) {
    int i, key, j;
    
    // Начинаем со второго элемента (первый считается отсортированным)
    for (i = 1; i < n; i++) {
        key = arr[i];  // Текущий элемент для вставки
        j = i - 1;
        
        // Сдвигаем элементы больше key вправо
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        
        // Вставляем key на правильную позицию
        arr[j + 1] = key;
    }
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n²) в худшем и среднем случае (обратно отсортированный)
//        O(n) в лучшем случае (уже отсортированный)
// Память: O(1) - сортировка на месте
// Стабильная: Да (сохраняет порядок равных элементов)

// Особенности:
// - Очень эффективна для почти отсортированных массивов
// - Эффективна для небольших массивов
// - Онлайн-алгоритм (может сортировать данные по мере поступления)
// - Используется в гибридных алгоритмах (TimSort, IntroSort)

// Применение:
// - Небольшие массивы (< 10-20 элементов)
// - Почти отсортированные данные
// - В качестве финальной стадии быстрых алгоритмов

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
#include <stdio.h>

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    printf("=== Сортировка вставками ===\n\n");
    
    // Тест 1: Обычный массив
    int arr1[] = {12, 11, 13, 5, 6};
    int n1 = 5;
    
    printf("Тест 1: Базовая сортировка\n");
    printf("До:    ");
    printArray(arr1, n1);
    
    insertion_sort(arr1, n1);
    
    printf("После: ");
    printArray(arr1, n1);
    printf("\n");
    
    // Тест 2: Обратный порядок (худший случай)
    int arr2[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int n2 = 10;
    
    printf("Тест 2: Обратный порядок (худший случай - O(n²))\n");
    printf("До:    ");
    printArray(arr2, n2);
    
    insertion_sort(arr2, n2);
    
    printf("После: ");
    printArray(arr2, n2);
    printf("\n");
    
    // Тест 3: Уже отсортирован (лучший случай)
    int arr3[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n3 = 10;
    
    printf("Тест 3: Уже отсортирован (лучший случай - O(n))\n");
    printf("До:    ");
    printArray(arr3, n3);
    
    insertion_sort(arr3, n3);
    
    printf("После: ");
    printArray(arr3, n3);
    printf("(Быстро! Каждый элемент проверяется только один раз)\n\n");
    
    // Тест 4: Почти отсортирован
    int arr4[] = {1, 2, 3, 4, 5, 7, 6, 8, 9, 10};
    int n4 = 10;
    
    printf("Тест 4: Почти отсортирован (ideal case)\n");
    printf("До:    ");
    printArray(arr4, n4);
    
    insertion_sort(arr4, n4);
    
    printf("После: ");
    printArray(arr4, n4);
    printf("(Очень быстро - почти O(n)!)\n\n");
    
    // Тест 5: Повторяющиеся элементы
    int arr5[] = {3, 5, 1, 5, 3, 2, 5, 1};
    int n5 = 8;
    
    printf("Тест 5: Повторяющиеся элементы (стабильная)\n");
    printf("До:    ");
    printArray(arr5, n5);
    
    insertion_sort(arr5, n5);
    
    printf("После: ");
    printArray(arr5, n5);
    printf("\n");
    
    // Визуализация работы алгоритма
    printf("=== Визуализация работы (массив [12, 11, 13, 5, 6]) ===\n");
    int demo[] = {12, 11, 13, 5, 6};
    int nd = 5;
    
    printf("Начало:      "); printArray(demo, nd);
    printf("             ^^ отсортированная часть\n\n");
    
    for (int i = 1; i < nd; i++) {
        int key = demo[i];
        int j = i - 1;
        
        printf("Шаг %d: вставляем %d\n", i, key);
        
        while (j >= 0 && demo[j] > key) {
            demo[j + 1] = demo[j];
            j--;
        }
        demo[j + 1] = key;
        
        printf("Результат:   ");
        printArray(demo, nd);
        for (int k = 0; k <= i; k++) printf("   ");
        printf("^^ отсортированная часть\n\n");
    }
    
    printf("=== Сравнение простых алгоритмов O(n²) ===\n\n");
    
    printf("Bubble Sort:\n");
    printf("  Лучший:  O(n) с оптимизацией\n");
    printf("  Средний: O(n²)\n");
    printf("  Худший:  O(n²)\n");
    printf("  Обмены:  Много\n");
    printf("  Стабильная: Да\n\n");
    
    printf("Selection Sort:\n");
    printf("  Лучший:  O(n²)\n");
    printf("  Средний: O(n²)\n");
    printf("  Худший:  O(n²)\n");
    printf("  Обмены:  O(n) - минимум!\n");
    printf("  Стабильная: Нет\n\n");
    
    printf("Insertion Sort: ★ ЛУЧШИЙ ДЛЯ МАЛЫХ/ПОЧТИ ОТСОРТИРОВАННЫХ\n");
    printf("  Лучший:  O(n) - САМЫЙ БЫСТРЫЙ!\n");
    printf("  Средний: O(n²)\n");
    printf("  Худший:  O(n²)\n");
    printf("  Обмены:  Средне\n");
    printf("  Стабильная: Да\n");
    printf("  Онлайн: Да (может сортировать поток данных)\n");
    
    return 0;
}
*/

