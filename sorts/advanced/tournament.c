// Турнирная сортировка (Tournament Sort / Selection Tree Sort)
// Модификация сортировки выбором с использованием турнирного дерева
//
// ============ КРАТКАЯ СПРАВКА ============
//
// ОСНОВНАЯ ФУНКЦИЯ:
//   void TournamentSort(int* arr, int size) - отсортировать массив
//
// АЛГОРИТМ:
//   1. Разбить исходный массив на подмассивы, размер каждого = степень двойки (1,2,4,8...)
//   2. Для каждого подмассива провести турнир:
//      - Каждый элемент сравнивается со своим соседом
//      - Победитель (меньший элемент) перемещается на следующий уровень турнира
//   3. Выбрать победителей каждого турнира и поместить их в новый массив
//   4. Повторить шаги 2 и 3 до тех пор, пока не будет сформирован отсортированный массив
//
// СТРУКТУРА:
//   Результат представляется в виде дерева выбора (турнирная таблица) - 
//   двоичное дерево, в котором для каждого двудутного узла один из сыновей
//   он сам (победитель), а другой больше своего отца (в корне - минимум)
//
// ОСОБЕННОСТЬ:
//   После каждого прохода остается гораздо больше порядковой информации,
//   чем просто минимальное значение. Это ускоряет последующие проходы.
//
// ==========================================

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Структура узла турнирного дерева
typedef struct {
    int value;       // Значение элемента
    int index;       // Индекс элемента в исходном массиве
} TreeNode;

// Построение турнирного дерева (снизу вверх)
// tree - турнирное дерево, n - количество листьев
void BuildTree(TreeNode* tree, int* arr, int n) {
    int treeSize = 2 * n - 1;  // Размер полного турнирного дерева
    
    // Заполняем листья (нижний уровень) значениями из массива
    for (int i = 0; i < n; i++) {
        tree[n - 1 + i].value = arr[i];
        tree[n - 1 + i].index = i;
    }
    
    // Строим турнирное дерево снизу вверх
    // Каждый родитель = победитель (минимум) из двух детей
    for (int i = n - 2; i >= 0; i--) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (right < treeSize && tree[right].value < tree[left].value) {
            tree[i] = tree[right];
        } else {
            tree[i] = tree[left];
        }
    }
}

// Обновление дерева после извлечения минимума
// Заменяем использованный элемент на "бесконечность" и пересчитываем путь к корню
void UpdateTree(TreeNode* tree, int n, int leafIndex) {
    // Заменяем извлеченный элемент на максимальное значение
    int treeIndex = n - 1 + leafIndex;
    tree[treeIndex].value = INT_MAX;
    
    // Обновляем путь от листа к корню
    while (treeIndex > 0) {
        int parent = (treeIndex - 1) / 2;
        int left = 2 * parent + 1;
        int right = 2 * parent + 2;
        int treeSize = 2 * n - 1;
        
        if (right < treeSize && tree[right].value < tree[left].value) {
            tree[parent] = tree[right];
        } else {
            tree[parent] = tree[left];
        }
        
        treeIndex = parent;
    }
}

// Турнирная сортировка
void TournamentSort(int* arr, int size) {
    // ЭТАП 1: Создаем турнирное дерево
    // Размер дерева: 2*n-1 узлов (n листьев + n-1 внутренних узлов)
    int treeSize = 2 * size - 1;
    TreeNode* tree = (TreeNode*)malloc(treeSize * sizeof(TreeNode));
    
    // Строим начальное турнирное дерево
    BuildTree(tree, arr, size);
    
    // ЭТАП 2-4: Извлекаем минимумы и обновляем дерево
    // На каждой итерации:
    // - Корень дерева содержит минимальный элемент (победитель турнира)
    // - Помещаем его в результирующий массив
    // - Заменяем использованный элемент на "бесконечность"
    // - Обновляем турнирное дерево
    
    for (int i = 0; i < size; i++) {
        // Победитель турнира - в корне дерева
        arr[i] = tree[0].value;
        int winnerIndex = tree[0].index;
        
        // Обновляем дерево: заменяем победителя на INT_MAX
        UpdateTree(tree, size, winnerIndex);
    }
    
    // Освобождаем память
    free(tree);
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n log n) во всех случаях
//        - Построение дерева: O(n)
//        - n итераций по O(log n) на обновление дерева
// Память: O(n) для турнирного дерева
// Стабильная: Нет (зависит от реализации)

// Особенности:
// - Гарантированная O(n log n)
// - Использует турнирное дерево (дерево выбора)
// - Каждое сравнение дает больше информации, чем в Selection Sort
// - После каждого прохода остается порядковая информация
// - Хорошо подходит для внешней сортировки больших файлов
// - Используется в алгоритмах слияния k отсортированных последовательностей

// Сравнение с Selection Sort:
// Selection Sort: O(n²) - каждый раз ищем минимум линейным поиском
// Tournament Sort: O(n log n) - используем дерево для быстрого поиска минимума

// Применение:
// - Внешняя сортировка (файлы на диске)
// - Слияние множества отсортированных последовательностей
// - Priority Queue реализации

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
int main() {
    printf("=== Турнирная сортировка (Tournament Sort) ===\n\n");
    
    // Тест 1: Обычный массив
    int arr1[] = {5, 3, 8, 1, 9, 2, 7, 4, 6};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    
    printf("Тест 1: Обычный массив\n");
    printf("До:    ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n");
    
    TournamentSort(arr1, n1);
    
    printf("После: ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n\n");
    
    // Тест 2: Обратный порядок
    int arr2[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    
    printf("Тест 2: Обратный порядок\n");
    printf("До:    ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n");
    
    TournamentSort(arr2, n2);
    
    printf("После: ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n\n");
    
    // Тест 3: Уже отсортированный
    int arr3[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    
    printf("Тест 3: Уже отсортированный\n");
    printf("До:    ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n");
    
    TournamentSort(arr3, n3);
    
    printf("После: ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n\n");
    
    // Тест 4: Повторяющиеся элементы
    int arr4[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    
    printf("Тест 4: Повторяющиеся элементы\n");
    printf("До:    ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n");
    
    TournamentSort(arr4, n4);
    
    printf("После: ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n\n");
    
    // Тест 5: Маленький массив
    int arr5[] = {3, 1, 2};
    int n5 = 3;
    
    printf("Тест 5: Маленький массив\n");
    printf("До:    ");
    for (int i = 0; i < n5; i++)
        printf("%d ", arr5[i]);
    printf("\n");
    
    TournamentSort(arr5, n5);
    
    printf("После: ");
    for (int i = 0; i < n5; i++)
        printf("%d ", arr5[i]);
    printf("\n\n");
    
    // Визуализация турнирного дерева
    printf("=== Принцип работы турнирного дерева ===\n\n");
    printf("Массив: [5, 3, 8, 1]\n\n");
    printf("Турнирное дерево (победители снизу вверх):\n");
    printf("           1          <- Корень: минимум из всех\n");
    printf("          / \\\n");
    printf("         3   1        <- Победители пар\n");
    printf("        / \\ / \\\n");
    printf("       5  3 8  1      <- Листья: исходные элементы\n\n");
    printf("1. Извлекаем корень (1), помещаем в результат\n");
    printf("2. Заменяем 1 на 'бесконечность', пересчитываем дерево\n");
    printf("3. Новый корень = следующий минимум (3)\n");
    printf("4. Повторяем до сортировки всего массива\n\n");
    
    printf("Результат: [1, 3, 5, 8]\n\n");
    
    printf("=== Сравнение с Selection Sort ===\n\n");
    printf("Selection Sort O(n²):\n");
    printf("  - Каждый раз линейно ищем минимум\n");
    printf("  - n итераций × O(n) поиска = O(n²)\n\n");
    printf("Tournament Sort O(n log n):\n");
    printf("  - Используем дерево для быстрого поиска\n");
    printf("  - n итераций × O(log n) обновление дерева = O(n log n)\n");
    printf("  - Каждое сравнение даёт больше информации!\n");
    
    return 0;
}
*/

