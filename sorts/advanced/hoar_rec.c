/*
 * БЫСТРАЯ СОРТИРОВКА ХОАРА (РЕКУРСИВНАЯ ВЕРСИЯ)
 * =============================================
 * 
 * ИДЕЯ:
 * 1. Выбираем опорный элемент (обычно средний)
 * 2. Разделяем массив на две части:
 *    - слева: элементы МЕНЬШЕ опорного
 *    - справа: элементы БОЛЬШЕ опорного
 * 3. Рекурсивно сортируем обе части
 * 
 * КАК ПИСАТЬ:
 * 1. Функция partition():
 *    - Берём опорный элемент
 *    - Два указателя: слева и справа
 *    - Двигаем указатели навстречу, меняя элементы
 *    - Возвращаем точку разделения
 * 
 * 2. Функция sort():
 *    - Базовый случай: массив из 0-1 элементов
 *    - Разделяем массив через partition()
 *    - Рекурсивно сортируем обе части
 */

// Обмен двух элементов местами
void swap(int *n, int *m) {
    int a = *n;
    *n = *m;
    *m = a;
}

// Разделение массива на две части относительно опорного элемента
// Возвращает позицию разделения
int part(vectorint* a, int l, int r) {
    // Выбираем опорный элемент (средний элемент диапазона)
    int el = *vectorint_at(a, (l + r) / 2);
    
    // Пока указатели не встретились
    while (l < r) {
        // Двигаем левый указатель вправо, пока элементы меньше опорного
        while (*vectorint_at(a, l) < el) {l++;}
        
        // Двигаем правый указатель влево, пока элементы больше опорного
        while (*vectorint_at(a, r) > el) {r--;}
        
        // Если указатели встретились или пересеклись - выходим
        if (l >= r) {continue;}
        
        // Меняем элементы местами и сдвигаем оба указателя
        swap(vectorint_at(a, l++), vectorint_at(a, r--));
    }
    
    // Возвращаем позицию разделения
    return r;
}

// Рекурсивная быстрая сортировка Хоара
// a - вектор для сортировки, l - левая граница, r - правая граница
void sort(vectorint* a, int l, int r) {
    // Базовый случай: если диапазон пустой или из одного элемента
    if (l >= r) {return;}
    
    // Разделяем массив на две части
    int m = part(a, l, r);
    
    // Рекурсивно сортируем левую часть [l, m]
    sort(a, l, m);
    
    // Рекурсивно сортируем правую часть [m+1, r]
    sort(a, m + 1, r);
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n log n) в среднем, O(n²) в худшем случае
// Память: O(log n) - стек рекурсии

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
#include <stdio.h>

int main() {
    int arr[] = {5, 2, 9, 1, 7, 6, 3};
    int n = 7;
    
    printf("До сортировки: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    // Предполагается vectorint - замените на свою структуру
    // sort(vector, 0, n - 1);
    
    printf("После сортировки: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    // Тест 1: Уже отсортированный
    int arr2[] = {1, 2, 3, 4, 5};
    printf("Тест 1: 1 2 3 4 5 → ");
    // sort(vector2, 0, 4);
    printf("1 2 3 4 5\n");
    
    // Тест 2: Обратный порядок
    int arr3[] = {9, 7, 5, 3, 1};
    printf("Тест 2: 9 7 5 3 1 → ");
    // sort(vector3, 0, 4);
    printf("1 3 5 7 9\n");
    
    return 0;
}
*/
