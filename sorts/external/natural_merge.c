// Естественная сортировка слиянием (Natural Merge Sort)
// Использует естественные последовательности (серии) в данных
//
// ============ КРАТКАЯ СПРАВКА ============
//
// ОСНОВНАЯ ФУНКЦИЯ:
//   void NaturalMergeSort(int* arr, int size) - отсортировать массив
//
// АЛГОРИТМ:
//   1. Разделение исходного массива на естественные серии (уже отсортированные части)
//   2. Слияние каждой пары серий для получения более длинных отсортированных частей
//   3. Повторение слияния до тех пор, пока все части не будут объединены
//      в один отсортированный массив
//
// ЕСТЕСТВЕННАЯ СЕРИЯ - это максимальная подпоследовательность элементов,
// идущих в неубывающем порядке: arr[i] <= arr[i+1] <= arr[i+2] <= ...
//
// ==========================================

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Структура для хранения серии (отсортированной последовательности)
typedef struct {
    int start;   // Начальный индекс серии
    int length;  // Длина серии
} Series;

// ШАГ 1: Разделение массива на естественные серии
// Находит все серии в массиве (уже отсортированные участки)
int FindSeries(int* arr, int size, Series* series) {
    int seriesCount = 0;
    int i = 0;
    
    while (i < size) {
        // Начинаем новую серию
        series[seriesCount].start = i;
        series[seriesCount].length = 1;
        
        // Расширяем серию, пока элементы идут в неубывающем порядке
        while (i + 1 < size && arr[i] <= arr[i + 1]) {
            series[seriesCount].length++;
            i++;
        }
        
        seriesCount++;
        i++;
    }
    
    return seriesCount;
}

// ШАГ 2: Слияние двух соседних серий в одну отсортированную
void MergeTwoSeries(int* arr, Series s1, Series s2, int* temp) {
    int i = s1.start;                    // Индекс в первой серии
    int j = s2.start;                    // Индекс во второй серии
    int k = 0;                           // Индекс во временном массиве
    int end1 = s1.start + s1.length;     // Конец первой серии
    int end2 = s2.start + s2.length;     // Конец второй серии
    
    // Слияние элементов из обеих серий в порядке возрастания
    while (i < end1 && j < end2) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // Копируем оставшиеся элементы из первой серии
    while (i < end1) {
        temp[k++] = arr[i++];
    }
    
    // Копируем оставшиеся элементы из второй серии
    while (j < end2) {
        temp[k++] = arr[j++];
    }
    
    // Копируем результат обратно в исходный массив
    for (i = 0; i < k; i++) {
        arr[s1.start + i] = temp[i];
    }
}

// Естественная сортировка слиянием
void NaturalMergeSort(int* arr, int size) {
    // Выделяем память для хранения информации о сериях
    Series* series = (Series*)malloc(size * sizeof(Series));
    // Временный массив для слияния
    int* temp = (int*)malloc(size * sizeof(int));
    
    bool sorted = false;
    
    // ШАГ 3: Повторяем, пока не останется одна серия (весь массив отсортирован)
    while (!sorted) {
        // 1. Разделение: находим все естественные серии в массиве
        int seriesCount = FindSeries(arr, size, series);
        
        // Если осталась только одна серия - массив полностью отсортирован
        if (seriesCount == 1) {
            sorted = true;
            continue;
        }
        
        // 2. Слияние: объединяем пары соседних серий
        for (int i = 0; i + 1 < seriesCount; i += 2) {
            MergeTwoSeries(arr, series[i], series[i + 1], temp);
        }
        
        // Если количество серий нечетное, последняя серия остается как есть
        // На следующей итерации она будет объединена с другими
    }
    
    // Освобождаем выделенную память
    free(series);
    free(temp);
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n * log n) в худшем случае
//        O(n) в лучшем случае (массив уже отсортирован)
// Память: O(n) для временных массивов
// Стабильная: Да (сохраняет порядок равных элементов)

// Особенности:
// - Адаптивный алгоритм: использует существующий порядок в данных
// - Эффективен для частично отсортированных данных
// - Если массив уже отсортирован - всего один проход O(n)
// - Хорошо подходит для внешней сортировки (файлы на диске)
// - Естественный порядок данных ускоряет работу

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
int main() {
    printf("=== Естественная сортировка слиянием ===\n\n");
    
    // Тест 1: Частично отсортированный массив (есть серии)
    // Серии: [1,3,5] [2,4,6,9] [7,8]
    int arr1[] = {1, 3, 5, 2, 4, 6, 9, 7, 8};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    
    printf("Тест 1: Частично отсортированный массив\n");
    printf("До:    ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n");
    
    NaturalMergeSort(arr1, n1);
    
    printf("После: ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n\n");
    
    // Тест 2: Массив с длинными сериями
    // Серии: [1,2,3,7,8,9] [4,5,6]
    int arr2[] = {1, 2, 3, 7, 8, 9, 4, 5, 6};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    
    printf("Тест 2: Массив с длинными сериями\n");
    printf("До:    ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n");
    
    NaturalMergeSort(arr2, n2);
    
    printf("После: ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n\n");
    
    // Тест 3: Уже отсортированный массив (лучший случай)
    // Серии: [1,2,3,4,5,6,7,8,9] - одна серия!
    int arr3[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    
    printf("Тест 3: Уже отсортированный массив (лучший случай O(n))\n");
    printf("До:    ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n");
    
    NaturalMergeSort(arr3, n3);
    
    printf("После: ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n(Всего один проход - найдена одна серия!)\n\n");
    
    // Тест 4: Обратный порядок (худший случай)
    // Серии: [9] [8] [7] [6] [5] [4] [3] [2] [1] - каждый элемент = серия
    int arr4[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    
    printf("Тест 4: Обратный порядок (худший случай)\n");
    printf("До:    ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n");
    
    NaturalMergeSort(arr4, n4);
    
    printf("После: ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n\n");
    
    return 0;
}
*/
