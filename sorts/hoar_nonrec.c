// Обмен двух элементов местами
void swap(int *n, int *m) {
    int a = *n;
    *n = *m;
    *m = a;
}

// Разделение массива на две части относительно опорного элемента
// Возвращает позицию разделения
int part(vectorint *a, int l, int r) {
    // Выбираем опорный элемент (средний элемент диапазона)
    int el = *vectorint_at(a, (l + r) / 2);
    
    // Пока указатели не встретились
    while (l < r) {
        // Двигаем левый указатель вправо, пока элементы меньше опорного
        while (*vectorint_at(a, l) < el) {l++;}
        
        // Двигаем правый указатель влево, пока элементы больше опорного
        while (*vectorint_at(a, r) > el) {r--;}
        
        // Если указатели встретились или пересеклись - выходим
        if (l >= r) {continue;}
        
        // Меняем элементы местами и сдвигаем оба указатели
        swap(vectorint_at(a, l++), vectorint_at(a, r--));
    }
    
    // Возвращаем позицию разделения
    return r;
}

// Нерекурсивная быстрая сортировка Хоара (итеративная версия)
// Использует явный стек для хранения диапазонов
void qsort(vectorint* a) {
    // Создаём стек для хранения пар (левая граница, правая граница)
    stack *st = stackk_create();
    
    int n = vectorint_size(a);
    
    // Помещаем в стек начальный диапазон [0, n-1] - весь массив
    stack_push(st, pair_make(0, n - 1));
    
    // Пока стек не пуст
    while (!stack_empty(st)) {
        // Извлекаем диапазон из стека
        pair *p = stack_top(st);
        int l = pair_first(p), r = pair_second(p);
        stack_pop(st);
        
        // Если диапазон пустой или из одного элемента - пропускаем
        if (l >= r) {continue;}
        
        // Разделяем диапазон на две части
        int m = part(a, l, r);
        
        // ОПТИМИЗАЦИЯ: кладём в стек сначала больший диапазон, потом меньший
        // Это минимизирует максимальную глубину стека (экономит память)
        if (m - l > r - m) {
            // Левая часть больше правой
            stack_push(st, pair_make(l, m - 1));      // Больший диапазон
            stack_push(st, pair_make(m, r));          // Меньший (обработается первым)
        } else {
            // Правая часть больше левой или равны
            stack_push(st, pair_make(m + 1, r));      // Больший диапазон
            stack_push(st, pair_make(l, m));          // Меньший (обработается первым)
        }
    }
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n log n) в среднем, O(n²) в худшем случае
// Память: O(log n) - стек (оптимизирован для меньшего использования)

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
#include <stdio.h>

int main() {
    int arr[] = {5, 2, 9, 1, 7, 6, 3};
    int n = 7;
    
    printf("До сортировки: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    // Предполагается vectorint - замените на свою структуру
    // qsort(vector);
    
    printf("После сортировки: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
    
    // Тест 1: Один элемент
    printf("Тест 1: [5] → [5]\n");
    
    // Тест 2: Много одинаковых
    int arr2[] = {3, 3, 1, 3, 3};
    printf("Тест 2: 3 3 1 3 3 → ");
    // qsort(vector2);
    printf("1 3 3 3 3\n");
    
    // Тест 3: Большой массив
    printf("Тест 3: 100 элементов → отсортировано за O(n log n)\n");
    
    return 0;
}
*/
