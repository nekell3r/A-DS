# Гладкая сортировка (Smoothsort)

## Автор и история

В 1981 году **Э. В. Дейкстра** (Edsger W. Dijkstra) предложил алгоритм гладкой сортировки, имеющий время работы порядка `n log n` в наихудшем случае и порядка `n` в случае почти отсортированной последовательности.

**Название алгоритма** указывает на то, что время его работы **плавно изменяется** от `O(n log n)` до `O(n)` в зависимости от того, насколько хорошо отсортирована исходная последовательность.

## Идея алгоритма

Как сказал Зайка на лекции: "ну вот, собственно, гладкая сортировка, процентов 5 из этого вам должно быть понятно". Вывод: пытаться понять идеально все - не надо. Вряд ли у вас получится.

Это **развитие пирамидальной сортировки**. Придумано Дейкстрой (кто, как не он мог придумать такой до безобразия сложный и крутой алгоритм). 

Как и пирамидальная сортировка обладает **линеаримфической сложностью** в среднем, но при этом обладает **естественностью** и на почти отсортированной последовательности работает за время, близкое к `O(n)`. 

Также скажите, что из-за **чрезмерной сложности** самого алгоритма эта сортировка широкого алгоритма не получила. Про алгоритм можно рассказать чуть-чуть.

## Принцип работы

### Два прохода

Предположим, что сортируемые элементы хранятся в массиве с индексами `0, ..., n - 1`.

Подобно пирамидальной, **гладкая сортировка обрабатывает массив в два прохода**:

1. **Первый проход**: Результатом первого прохода является построение из элементов массива нескольких частично упорядоченных деревьев (пирамид)

2. **Второй проход**: При втором проходе элементы, начиная с наибольшего, занимают предназначенные им места

### Числа Леонардо

Алгоритм использует **последовательность чисел Леонардо** \(L_k\): `1, 1, 3, 5, 9, 15, ...`

Здесь \(L_0 = L_1 = 1\), \(L_{k+2} = L_{k+1} + L_k + 1\).

Любое натуральное число может быть представлено в леонардовой системе счисления:

$$\overline{p_k p_{k-1} \ldots p_1 p_0} = \sum_{i=0}^{k} p_i L_i, \quad p_i \in \{0,1\}$$

причем две единицы могут идти подряд только в том случае, если справа от них нет других единиц.

Натуральное число `m` удобно хранить в виде пары `(p, L)`, где:
- `p` — натуральное число, двоичные цифры которого указывают, входит ли соответствующее число Леонардо в представление `m`
- `L` — последовательность значений чисел Леонардо

### Структура данных

Будем называть отрезком подпоследовательность идущих подряд элементов, длина которой является числом Леонардо, а стандартным разбиением последовательности длины `m` — такое ее разбиение на отрезки, что первый отрезок имеет максимально возможную длину `l`, а за ним следует стандартное разбиение последовательности длины `m - l`.

Каждый отрезок можно рассматривать как дерево. Если обозначить отрезок длины \(L_k\) через `< L_k >`, то структура дерева:

$$< L_k > = < L_{k-1} > < L_{k-2} > < R >$$

где `< R >` — корень дерева. Сыновьями корня считаются корни отрезков `< L_{k-1} >` и `< L_{k-2} >`. Отрезки `< L_1 >` и `< L_0 >` состоят из корня без сыновей.

### Допустимые и надежные отрезки

- **Допустимый отрезок**: Отрезок длины 1 является допустимым и надежным. Отрезок `< L_n >` является допустимым, если `< L_{n-1} >` и `< L_{n-2} >` являются надежными
  
- **Надежный отрезок**: Отрезок `< L_n >` является надежным, если он допустимый и значение корня не меньше значений его сыновей

### Условия инвариантов

При первом проходе после обработки `i`-го элемента выполняются условия:

**P₁**: самый правый отрезок стандартного разбиения префикса — допустимый, все остальные — надежные

**P₂**: значения корней надежных отрезков стандартного разбиения префикса, которые также являются отрезками стандартного разбиения всей последовательности, не убывают слева направо

Выполнение условия \(P_1 \& P_2\) гарантирует, что `i`-й элемент является максимальным среди элементов префикса и, следовательно, стоит на своем месте.

## Сложностная оценка

**Временная сложность:**
- **Наихудший случай:** `O(n log n)`
- **Почти отсортированная последовательность:** `O(n)`
- **В среднем:** плавно изменяется между этими значениями

**Пространственная сложность:** `O(1)` — сортировка на месте

## Преимущества

- **Адаптивность**: Время работы плавно адаптируется от `O(n log n)` до `O(n)` в зависимости от степени упорядоченности данных
- **Естественность**: Эффективна на почти отсортированных данных
- **Гарантии**: Всегда `O(n log n)` в худшем случае
- **In-place**: Не требует дополнительной памяти
- **Теоретическая элегантность**: Красивое математическое обоснование

## Недостатки

- **Чрезмерная сложность реализации**: Из-за сложности самого алгоритма эта сортировка широкого распространения не получила
- **Большие константы**: На практике может проигрывать более простым алгоритмам
- **Сложность понимания**: Требует глубокого понимания структуры данных и чисел Леонардо
- **Отладка**: Очень сложно отлаживать и поддерживать код

## Практическое применение

Гладкая сортировка представляет больше **теоретический**, чем практический интерес. В реальных приложениях обычно используют более простые алгоритмы (Quicksort, Heapsort, Timsort), которые легче реализовать и поддерживать.

Однако алгоритм демонстрирует важные концепции:
- Адаптивность алгоритмов к характеру входных данных
- Возможность достижения оптимального поведения на разных типах входных данных
- Баланс между теоретической оптимальностью и практической применимостью

## Связь с другими алгоритмами

- **Пирамидальная сортировка (Heapsort)**: Гладкая сортировка является развитием пирамидальной
- **Числа Леонардо**: Использует специальную числовую последовательность вместо обычного двоичного дерева

## Экспериментальные данные

По данным эксперимента Н. Вирта (массив из 2048 элементов, скалярный ключ):

| Упорядоченный | Случайный | Обратный порядок |
|---------------|-----------|------------------|
| 0,22 | 2,22 | 2,12 |

Как видно, на упорядоченном наборе гладкая сортировка значительно быстрее (0,22 против 2,22), что подтверждает её естественность и адаптивность.

## Заключение

Гладкая сортировка — это **интеллектуальный вызов** от Дейкстры, демонстрирующий, как можно объединить лучшие свойства разных алгоритмов. Но на практике её сложность перевешивает преимущества, поэтому она остается скорее академическим примером элегантного, но непрактичного решения.

