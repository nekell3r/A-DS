// Двоичная сортировка вставками (Binary Insertion Sort)
// Оптимизация обычной сортировки вставками с использованием бинарного поиска
//
// ============ КРАТКАЯ СПРАВКА ============
//
// ОСНОВНАЯ ФУНКЦИЯ:
//   void BinaryInsertionSort(int arr[], int n) - отсортировать массив
//
// АЛГОРИТМ:
//   1. Для каждого элемента, начиная со второго
//   2. Используем бинарный поиск для нахождения позиции вставки 
//      в отсортированной части [0, i-1]
//   3. Сдвигаем элементы вправо для освобождения места
//   4. Вставляем элемент на найденную позицию
//
// ОТЛИЧИЕ ОТ ОБЫЧНОЙ INSERTION SORT:
//   - Обычная: O(n) сравнений для поиска позиции (линейный поиск)
//   - Двоичная: O(log n) сравнений для поиска позиции (бинарный поиск)
//   - НО! Количество перемещений остается O(n²) в худшем случае
//
// ==========================================

#include <stdio.h>

// Двоичная сортировка вставками
void BinaryInsertionSort(int arr[], int n) {
    int i, j, L, R, m;
    int x;
    
    // Проходим по всем элементам, начиная со второго
    for (i = 1; i < n; i++) {
        x = arr[i];  // Элемент для вставки
        L = 0;       // Левая граница бинарного поиска
        R = i - 1;   // Правая граница бинарного поиска
        
        // ШАГ 1: БИНАРНЫЙ ПОИСК позиции для вставки
        // Ищем место, куда вставить x в отсортированной части [0, i-1]
        // Цель: найти L, где все элементы левее L меньше или равны x
        while (L < R) {
            m = (L + R) / 2;  // Середина
            
            if (arr[m] <= x) {
                L = m + 1;     // Ищем в правой половине
            } else {
                R = m;         // Ищем в левой половине
            }
        }
        
        // После цикла L указывает на позицию для вставки
        // (первый элемент > x, или конец отсортированной части)
        
        // ШАГ 2: СДВИГ элементов вправо
        // Сдвигаем все элементы от L до i-1 на одну позицию вправо
        for (j = i; j >= L + 1; j--) {
            arr[j] = arr[j - 1];
        }
        
        // ШАГ 3: ВСТАВКА элемента на найденную позицию
        arr[L] = x;
    }
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n² log n) в худшем случае
//        - Сравнений: O(n log n) благодаря бинарному поиску
//        - Перемещений: O(n²) в худшем случае (обратный порядок)
//        O(n log n) в лучшем случае (массив почти отсортирован)
// Память: O(1) - сортировка на месте
// Стабильная: Да (сохраняет порядок равных элементов)

// Особенности:
// - Меньше СРАВНЕНИЙ чем у обычной insertion sort: O(n log n) вместо O(n²)
// - Количество ПЕРЕМЕЩЕНИЙ остается O(n²) - узкое место алгоритма
// - Полезна, когда сравнения дорогие (сложные объекты, строки)
// - Для примитивных типов выигрыш незначителен
// - Стабильная сортировка
// - Простая реализация

// Когда использовать:
// - Сравнения элементов очень дорогие
// - Маленькие массивы (n < 50)
// - Почти отсортированные данные
// - Нужна стабильная сортировка

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
int main() {
    printf("=== Двоичная сортировка вставками ===\n\n");
    
    // Тест 1: Обычный массив
    int arr1[] = {64, 34, 25, 12, 22, 11, 90};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    
    printf("Тест 1: Обычный массив\n");
    printf("До:    ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n");
    
    BinaryInsertionSort(arr1, n1);
    
    printf("После: ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n\n");
    
    // Тест 2: Обратный порядок (худший случай)
    int arr2[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    
    printf("Тест 2: Обратный порядок (худший случай)\n");
    printf("До:    ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n");
    
    BinaryInsertionSort(arr2, n2);
    
    printf("После: ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n\n");
    
    // Тест 3: Почти отсортированный (лучший случай)
    int arr3[] = {1, 2, 3, 5, 4, 6, 7, 8, 9};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    
    printf("Тест 3: Почти отсортированный массив\n");
    printf("До:    ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n");
    
    BinaryInsertionSort(arr3, n3);
    
    printf("После: ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n\n");
    
    // Тест 4: Одинаковые элементы
    int arr4[] = {5, 2, 2, 8, 2, 9, 2, 3};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    
    printf("Тест 4: Массив с повторяющимися элементами\n");
    printf("До:    ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n");
    
    BinaryInsertionSort(arr4, n4);
    
    printf("После: ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n\n");
    
    return 0;
}
*/

// ============ ВИЗУАЛИЗАЦИЯ РАБОТЫ ============
//
// Исходный массив: [64, 34, 25, 12, 22]
//
// i=1, x=34:
//   Отсортированная часть: [64]
//   Бинарный поиск: 34 < 64 → позиция 0
//   Сдвиг: [64, 64, 25, 12, 22]
//   Вставка: [34, 64, 25, 12, 22]
//
// i=2, x=25:
//   Отсортированная часть: [34, 64]
//   Бинарный поиск: 25 < 34 → позиция 0
//   Сдвиг: [34, 34, 64, 12, 22]
//   Вставка: [25, 34, 64, 12, 22]
//
// i=3, x=12:
//   Отсортированная часть: [25, 34, 64]
//   Бинарный поиск: 12 < 25 → позиция 0
//   Сдвиг: [25, 25, 34, 64, 22]
//   Вставка: [12, 25, 34, 64, 22]
//
// i=4, x=22:
//   Отсортированная часть: [12, 25, 34, 64]
//   Бинарный поиск: 12 < 22 < 25 → позиция 1
//   Сдвиг: [12, 25, 25, 34, 64]
//   Вставка: [12, 22, 25, 34, 64]
//
// Результат: [12, 22, 25, 34, 64]
//
// ============ СРАВНЕНИЕ С ОБЫЧНОЙ INSERTION SORT ============
//
// | Характеристика        | Обычная Insertion | Binary Insertion |
// |-----------------------|-------------------|------------------|
// | Сравнения             | O(n²)             | O(n log n)       |
// | Перемещения           | O(n²)             | O(n²)            |
// | Общая сложность       | O(n²)             | O(n²)            |
// | Константа             | Меньше            | Больше           |
// | Для примитивов        | Быстрее           | Медленнее        |
// | Для сложных объектов  | Медленнее         | Быстрее          |
// | Стабильность          | Да                | Да               |
//
// ВЫВОД: Binary Insertion Sort выгодна только когда:
//   - Сравнения элементов дорогие (например, сравнение строк, объектов)
//   - Массив маленький
//   - Для int/float выигрыш минимален или его вообще нет!

