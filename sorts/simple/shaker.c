// Шейкерная сортировка (Shaker Sort / Cocktail Sort)
// Улучшенная версия пузырьковой сортировки с двунаправленным проходом
//
// ============ КРАТКАЯ СПРАВКА ============
//
// ОСНОВНАЯ ФУНКЦИЯ:
//   void ShakeSort(int* arr, int size) - отсортировать массив
//
// АЛГОРИТМ:
//   1. Устанавливаем левую (L) и правую (R) границы неотсортированной части
//   2. Проход СПРАВА НАЛЕВО: "всплывают" маленькие элементы влево
//      - Сравниваем соседние элементы
//      - Меняем местами, если левый больше правого
//      - Запоминаем позицию последнего обмена (k)
//      - Обновляем левую границу: L = k + 1
//   3. Проход СЛЕВА НАПРАВО: "тонут" большие элементы вправо
//      - Сравниваем соседние элементы
//      - Меняем местами, если левый больше правого
//      - Запоминаем позицию последнего обмена (k)
//      - Обновляем правую границу: R = k
//   4. Повторяем, пока L < R
//
// ОТЛИЧИЕ ОТ BUBBLE SORT:
//   - Bubble Sort: только один проход (слева направо или справа налево)
//   - Shaker Sort: два прохода за итерацию (туда и обратно)
//   - Лучше обрабатывает "черепах" (маленькие элементы в конце)
//
// ==========================================

#include <stdio.h>
#include <stdlib.h>

// Шейкерная сортировка
void ShakeSort(int* arr, int size) {
    int L = 0;           // Левая граница неотсортированной части
    int R = size - 1;    // Правая граница неотсортированной части
    int k = R;           // Позиция последнего обмена

    // Продолжаем, пока границы не сойдутся
    do {
        // ПРОХОД 1: Справа налево (маленькие элементы "всплывают" влево)
        for (int i = R; i > L; i--) {
            if (arr[i] < arr[i - 1]) {
                // Обмен элементов
                int temp = arr[i - 1];
                arr[i - 1] = arr[i];
                arr[i] = temp;
                k = i;  // Запоминаем позицию обмена
            }
        }
        L = k;  // Всё левее k уже отсортировано

        // ПРОХОД 2: Слева направо (большие элементы "тонут" вправо)
        for (int i = L; i < R; i++) {
            if (arr[i] > arr[i + 1]) {
                // Обмен элементов
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                k = i;  // Запоминаем позицию обмена
            }
        }
        R = k;  // Всё правее k уже отсортировано

    } while (L < R);
}

// ============ СЛОЖНОСТЬ ============
// Время: O(n²) в среднем и худшем случае
//        O(n) в лучшем случае (уже отсортирован)
// Память: O(1) - сортировка на месте
// Стабильная: Да (сохраняет порядок равных элементов)

// Особенности:
// - Быстрее обычной пузырьковой сортировки
// - Лучше обрабатывает "черепах" (маленькие элементы в конце массива)
// - Двунаправленные проходы уменьшают количество итераций
// - Адаптивная: O(n) для почти отсортированных данных
// - Простая реализация

// Сравнение с Bubble Sort:
// + Быстрее на случайных данных (меньше проходов)
// + Эффективнее для "черепах"
// - Немного сложнее код
// = Та же асимптотическая сложность O(n²)

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
int main() {
    printf("=== Шейкерная сортировка (Cocktail Sort) ===\n\n");
    
    // Тест 1: Обычный массив
    int arr1[] = {1, 7, 5, 3, 9, 11, 12, 8, 23};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    
    printf("Тест 1: Обычный массив\n");
    printf("До:    ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n");
    
    ShakeSort(arr1, n1);
    
    printf("После: ");
    for (int i = 0; i < n1; i++)
        printf("%d ", arr1[i]);
    printf("\n\n");
    
    // Тест 2: "Черепаха" в конце (маленький элемент в конце массива)
    // Bubble Sort будет медленным, Shaker Sort справится быстрее
    int arr2[] = {2, 3, 4, 5, 6, 7, 8, 9, 1};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    
    printf("Тест 2: 'Черепаха' в конце (маленький элемент справа)\n");
    printf("До:    ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n");
    
    ShakeSort(arr2, n2);
    
    printf("После: ");
    for (int i = 0; i < n2; i++)
        printf("%d ", arr2[i]);
    printf("\n(Shaker Sort эффективно двигает 1 влево!)\n\n");
    
    // Тест 3: Обратный порядок
    int arr3[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    
    printf("Тест 3: Обратный порядок\n");
    printf("До:    ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n");
    
    ShakeSort(arr3, n3);
    
    printf("После: ");
    for (int i = 0; i < n3; i++)
        printf("%d ", arr3[i]);
    printf("\n\n");
    
    // Тест 4: Уже отсортированный массив (лучший случай)
    int arr4[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    
    printf("Тест 4: Уже отсортированный массив (лучший случай O(n))\n");
    printf("До:    ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n");
    
    ShakeSort(arr4, n4);
    
    printf("После: ");
    for (int i = 0; i < n4; i++)
        printf("%d ", arr4[i]);
    printf("\n(Всего один проход - без обменов!)\n\n");
    
    // Тест 5: Повторяющиеся элементы
    int arr5[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    int n5 = sizeof(arr5) / sizeof(arr5[0]);
    
    printf("Тест 5: Повторяющиеся элементы\n");
    printf("До:    ");
    for (int i = 0; i < n5; i++)
        printf("%d ", arr5[i]);
    printf("\n");
    
    ShakeSort(arr5, n5);
    
    printf("После: ");
    for (int i = 0; i < n5; i++)
        printf("%d ", arr5[i]);
    printf("\n\n");
    
    return 0;
}
*/

