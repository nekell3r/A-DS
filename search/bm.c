#include <stdio.h>
#include <string.h>

int main()
{
    const int Nmax = 10000;
    const int Mmax = 100;
    
    int i, j, k, i0, M, N;
    
    char s[Nmax]; /* строка */
    
    char p[Mmax]; /* образец */
    int d[256];
    
    gets(s); /* Ввод текста, в котором будет осуществляться поиск */
    N = strlen(s);
    
    while(1)
    {
        putchar(10);
        printf(">_");
        gets(p); /* Считывание образца */
        M = strlen(p);
        
        if(M == 0) /* Если образец пуст, поиск не выполняется */
            return 0;
        
        /* Заполнение таблицы сдвигов d */
        for(i = 0; i <= 255; i++)
            d[i] = M; /* Пока все буквы в образце отсутствуют */
        
        for(j = 0; j <= M-2; j++)
            d[(int)p[j]] = M-j-1; /*В массиве d остаётся самое правое (последнее) вхождение буквы в образец (ближайшее к концу при чтении слева направо)*/
        
        /* Поиск подстроки */
        i = M;
        i0 = 0;
        do
        {
            putchar(10);
            
            if(i0 > 0)
                for(k = 0; k < i0; k++)
                    printf("_");
            
            while(i0 < 1)
            {
                printf("%c",s[i0]);
                i0++;
            }
            
            j = M;
            k = i;
            
            do
            {
                k--;
                j--;
            }
            while(!(j < 0 || (p[j] != s[k])));
            
            i = i + d[(int)s[i-1]];
        }
        while(!(j < 0 || i> N));
        
        if(j<0) printf("!_Найден\n");
    }
}

// ============ СЛОЖНОСТЬ ============
// Построение таблицы: O(m + σ) где m - длина образца, σ - размер алфавита
// Лучший случай: O(n/m) - очень быстро!
// Худший случай: O(n*m)
// Средний случай: O(n) - субхлинейное время
// Память: O(σ) - таблица сдвигов для алфавита (256 для ASCII)
// BM - один из самых быстрых алгоритмов на практике!

// ============ ПРИМЕР ИСПОЛЬЗОВАНИЯ ============

/*
Алгоритм Бойера-Мура (Boyer-Moore)

Идея: сравнение справа налево, большие сдвиги при несовпадении

Пример поиска "EXAMPLE" в тексте:

Таблица d для "EXAMPLE":
  Все символы: 7 (длина образца)
  E: 6 (последнее вхождение)
  L: 2
  P: 1
  M: 3
  A: 4
  X: 5

Преимущества:
- Просматривает текст справа налево
- Может пропускать большие куски текста
- На практике быстрее КМП

Тест 1: Найти "needle" в "haystack with needle inside"
Результат: найдено на позиции 14

Тест 2: Найти редкий паттерн
"ZZZZZ" в "AAAABBBBCCCCDDDDZZZZZ"
Результат: найдено на позиции 16 (быстро!)

Тест 3: Английский текст
Поиск слова очень быстр из-за больших сдвигов
*/

