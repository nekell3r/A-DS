## 7.3.1 Типизация языка

* **Типизация** — система правил, по которой язык делит значения/объекты на типы.
* Бывают **бестиповые** (исторически — B, BCPL и т.п.) и **типизированные** языки.
* В мейнстрим-языках (в духе Паскаля) продвигается **строгая статическая типизация**:
  тип каждой переменной, выражения, параметра фиксируется на этапе компиляции и **не меняется** во время исполнения.
* Плюсы строгой типизации: раннее обнаружение ошибок, понятные интерфейсы, лучшее документирование и оптимизация.

## 7.3.2 Контроль типов

* **Контроль типов** = проверка соответствия типов переменных, выражений, параметров и т. п.
* **Статический контроль** (при компиляции):

  * отбираем синтаксически правильные программы и из них — **типо-правильные** (совместимость типов при присваивании, вызовах, операциях и т. д.);
  * типовые ошибки ловятся **до запуска**.
* **Динамический контроль** (во время исполнения): язык/среда должны уметь **обнаружить** типовую ошибку и определить поведение (останов/исключение/продолжение).
* На практике встречаются смеси: часть правил проверяется статически, часть — динамически.
* Итог: типизация + контроль типов — основа «защиты» языка: принадлежность значений к типам, допустимые операции/контексты, реакции на нарушения.

## 7.3.3 Преобразование и передача типов

* Если в выражении встречаются разные типы, возможны два механизма:
  **преобразование значения** и **передача (трансляция) типа**.
* **Преобразование (conversion/coercion)** — меняем *значение/представление*, чтобы подогнать под целевой тип (например, `int → real`). Может быть не точным/необратимым и стоить времени.
* **Передача типа (transferring type)** — меняем **интерпретацию** той же области памяти как значения другого типа (по сути — «перетипизация» без изменения битов). Это ближе к «кастам», опаснее, но нужно для низкоуровневых задач (файлы, двоичная запись, трактовка слова памяти как иной структуры).
* В Паскале современного толка часто используются именованные «функции-передачи типа» (`float(3) → 3.0`) и приведения; смысл — сделать операции явными.

## 7.3.4 Адресный тип

* Для унифицированной интерпретации памяти вводят **родовой адресный тип** (в тексте — `word`) — «одно машинное слово» без собственного подтипа данных.
* Его назначение — **ослабить контроль** при передаче параметров/работе с памятью: формальный параметр `word` совместим с любым фактическим, помещающимся в слово.
* Более универсальный вариант — **родовой (нестрогий) указатель**: `pointer to word` (или просто «untyped pointer»). Он обходит обычные проверки совместимости типов и потому называется **адресным/родовым**.
* Опасность: можно нарушить типовую безопасность; в Паскале разрешают, но рекомендуют применять для низкоуровневого кода (драйверы, адресная арифметика в стиле C) и очень аккуратно.

## 7.3.5 Родовые (generic) модули

* **Родовой модуль** — модуль, который можно использовать с разными типами данных (например, «стек любых элементов»).
* В чистом Паскале это **противоречит строгой типизации**: один импортирует модуль как стек целых, другой — как стек строк. Если контроль типов ослаблен, строгая типизация нарушается.
* Распространённый компромисс: реализовать структуру данных поверх `word`/«массива word» — работает, но снимает многие проверки (нет контроля границ/совместимости элементов).
* Вывод: родовые модули удобны и практичны, но их реализация в «классическом» Паскале часто опирается на обход типовой системы.

## 7.3.6 Полиморфизм

* **Параметрические/полиморфные типы** — операции или сущности, которые допускают аргументы **разных** (или абстрактных) типов.
  Примеры: перегруженный `+` (для целых и вещественных), абстрактные операции над ADT (например, `empty()`, `insert()` у мультимножества), универсальные функции.
* Полиморфизм бывает:

  * **через параметризацию** (тип — параметр модуля/процедуры),
  * **через спецификацию** (задаём поведение интерфейсом, не привязываясь к реализации).
* Идея: описываем поведение через **контракт**, а конкретный тип подставляется позже.

## 7.3.7 Процедурный тип

* **Процедурный тип** — значениями выступают **процедуры/функции** определённой сигнатуры.

  * **Константы** процедурного типа — имена глобально объявленных процедур.
  * **Переменные** процедурного типа могут получать эти значения (присваивание), сравниваться (ограниченно), и главное — **вызываться** через переменную.
  * Все процедуры **без параметров** совместимы и образуют единый процедурный тип; для процедур с параметрами — совместимость по сигнатуре.
* Польза: модульность и универсальность (храним «коллбек» сравнения/обработки в структуре данных; параметризуем модуль поведением).
* Опасность: сочетание **нестрогих указателей** и процедурных типов = риск исполнять «что угодно по адресу» (классическая «взрывоопасная смесь»). Использовать аккуратно, особенно при раздельной компиляции модулей.
