# Бинарное дерево (Binary Tree)

Реализации бинарного дерева с двумя подходами к хранению данных.

## Файлы

### `dyn.c` - Динамическая реализация (на указателях)

Классическая реализация бинарного дерева с использованием указателей.

**Структура:**
```c
struct Tree_Node_ {
    int data;
    Tree_Node* left;   // Левый ребёнок
    Tree_Node* right;  // Правый ребёнок
};
```

**Основные функции:**
- `init()` - инициализация пустого дерева
- `build(left, root_value, right)` - построение дерева из корня и поддеревьев
- `build_from_array(values, n)` - построение сбалансированного дерева из массива
- `is_empty(tree)` - проверка пустоты
- `root_value(tree)` - получение значения корня
- `left_subtree(tree)` - получение левого поддерева
- `right_subtree(tree)` - получение правого поддерева
- `destroy(node)` - освобождение памяти

**Алгоритмы обхода:**
- `preorder(node)` - прямой обход (корень → левый → правый)
- `inorder(node)` - симметричный обход (левый → корень → правый)
- `postorder(node)` - обратный обход (левый → правый → корень)

**Пример построения из массива:**
```c
int values[] = {1, 2, 3, 4, 5, 6, 7};
int* ptr = values;
Tree_Node* root = build_from_array(&ptr, 7);

// Результат:
//       1
//      / \
//     2   3
//    / \ / \
//   4  5 6  7
```

**Сложность:**
- Построение: O(n)
- Обход: O(n)
- Память: O(n) для дерева + O(h) для рекурсии (h - высота)

**Преимущества:**
- ✅ Гибкость - легко добавлять/удалять узлы
- ✅ Только используемая память
- ✅ Естественная структура

**Недостатки:**
- ❌ Фрагментация памяти
- ❌ Накладные расходы на указатели
- ❌ Плохая локальность данных (cache-unfriendly)

---

### `mas.c` - Реализация на массиве

Компактная реализация бинарного дерева с использованием массива.

**Структура:**
```c
typedef struct {
    int* data;         // Массив данных
    size_t capacity;   // Ёмкость массива
} Tree;
```

**Индексация:**
Для узла с индексом `i`:
- Левый ребёнок: `2*i + 1`
- Правый ребёнок: `2*i + 2`
- Родитель: `(i-1) / 2`

**Основные функции:**
- `init()` - инициализация с фиксированной ёмкостью
- `build(left, root_value, right)` - построение дерева
- `build_from_array(values, n)` - копирование массива в дерево
- `is_empty(tree)` - проверка пустоты
- `root(tree)` - получение значения корня
- `destroy(tree)` - освобождение памяти

**Алгоритмы обхода:**
- `preorder(tree, idx)` - прямой обход
- `inorder(tree, idx)` - симметричный обход
- `postorder(tree, idx)` - обратный обход

**Пример:**
```c
int values[] = {1, 2, 3, 4, 5, 6, 7};
Tree* tree = build_from_array(values, 7);

// Массив: [1, 2, 3, 4, 5, 6, 7]
// Дерево:
//       1 (idx=0)
//      / \
//     2   3 (idx=1,2)
//    / \ / \
//   4  5 6  7 (idx=3,4,5,6)
```

**Сложность:**
- Построение: O(n)
- Обход: O(n)
- Память: O(capacity) - фиксированный размер

**Преимущества:**
- ✅ Отличная локальность данных (cache-friendly)
- ✅ Простота реализации
- ✅ Быстрый доступ к родителю/детям по формуле
- ✅ Нет накладных расходов на указатели

**Недостатки:**
- ❌ Фиксированная ёмкость
- ❌ Неэффективно для несбалансированных деревьев
- ❌ Память тратится на пустые узлы

---

## Сравнение реализаций

| Критерий | Динамическая | Массив |
|----------|-------------|--------|
| Память | Только используемые узлы | Фиксированная |
| Локальность | Плохая | Отличная |
| Гибкость | Высокая | Низкая |
| Доступ к узлам | По указателям | По формуле |
| Использование | Общие случаи | Полные/почти полные деревья |

## Когда использовать?

**Динамическую реализацию (`dyn.c`):**
- Размер дерева неизвестен заранее
- Много операций вставки/удаления
- Дерево может быть несбалансированным
- BST, AVL-деревья, красно-чёрные деревья

**Реализацию на массиве (`mas.c`):**
- Полные или почти полные деревья
- Размер известен заранее
- Нужна высокая производительность
- Heap, приоритетные очереди

## Компиляция и запуск

```bash
# Динамическая реализация
gcc dyn.c -o btree_dyn
./btree_dyn

# Реализация на массиве
gcc mas.c -o btree_mas
./btree_mas
```

**Примечание:** Раскомментируйте функцию `main()` в файлах перед компиляцией.

## Примеры использования

### Построение и обход дерева (динамическая)
```c
int values[] = {1, 2, 3, 4, 5};
int* ptr = values;
Tree_Node* root = build_from_array(&ptr, 5);

printf("Pre-order: ");
preorder(root);    // 1 2 4 5 3

printf("\nIn-order: ");
inorder(root);     // 4 2 5 1 3

printf("\nPost-order: ");
postorder(root);   // 4 5 2 3 1

destroy(root);
```

### Построение и обход дерева (массив)
```c
int values[] = {1, 2, 3, 4, 5, 6, 7};
Tree* tree = build_from_array(values, 7);

printf("Pre-order: ");
preorder(tree, 0);    // 1 2 4 5 3 6 7

destroy(tree);
```

## Ресурсы

- [Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/binary-tree-data-structure/)
- [Tree Traversals](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)
- [Array vs Pointer representation](https://www.geeksforgeeks.org/binary-tree-array-implementation/)

