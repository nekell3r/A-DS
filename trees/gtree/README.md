# Общее дерево (General Tree / n-арное дерево)

Реализация общего дерева, где каждый узел может иметь произвольное количество детей.

## Файлы

### `dyn.c` - Представление "первый ребёнок - следующий брат"

## Концепция

**Общее дерево (General Tree)** - это дерево, в котором узел может иметь любое количество детей (в отличие от бинарного дерева, где максимум 2).

### Представление "первый ребёнок - следующий брат"

Эффективный способ представления общего дерева с помощью **двух указателей**:

```c
struct node {
    int val;              // Значение узла
    node* first_child;    // Первый ребёнок
    node* main_bro;       // Следующий брат (next sibling)
};
```

**Идея:** Вместо хранения списка всех детей, храним:
1. Указатель на **первого ребёнка**
2. Указатель на **следующего брата** (связываем детей между собой)

### Пример структуры

```
Дерево:
       1
     / | \
    2  3  4
   /|\
  5 6 7

Представление с указателями:

    1
    ↓ first_child
    2 → 3 → 4  (братья связаны через main_bro)
    ↓ first_child
    5 → 6 → 7  (братья связаны через main_bro)
```

**Ключевое преимущество:** нужно только 2 указателя на узел (как в бинарном дереве!), но можно представить n-арное дерево.

## Основные функции

### Базовые операции
```c
tree_ov init()                                    // Создание пустого дерева
node* create_node(int value)                      // Создание узла
tree_ov build(int root_value, tree_ov* children, int count)  // Построение
bool is_empty(tree_ov tree)                      // Проверка пустоты
int root_value(tree_ov tree)                     // Значение корня
tree_ov first_child(tree_ov tree)               // Первый ребёнок
tree_ov next_sibling(tree_ov tree)              // Следующий брат
void destroy(tree_ov tree)                       // Удаление дерева
```

### Построение из массива
```c
tree_ov build_from_array(int values[], int n)
```

Создаёт **одноуровневое дерево**: первый элемент - корень, остальные - его дети.

**Пример:**
```c
int values[] = {1, 2, 3, 4, 5};
tree_ov tree = build_from_array(values, 5);

// Результат:
//       1
//     / | \ \
//    2  3  4  5
```

### Обход дерева

#### Pre-order (прямой обход)
```c
void preorder(tree_ov tree)  // Корень → Дети → Братья
```

**Порядок:**
1. Обработать текущий узел
2. Рекурсивно обойти первого ребёнка
3. Рекурсивно обойти следующего брата

**Пример для дерева:**
```
       1
      / \
     2   3
    / \
   4   5

Pre-order: 1 2 4 5 3
```

#### Post-order (обратный обход)
```c
void postorder(tree_ov tree)  // Дети → Корень → Братья
```

**Порядок:**
1. Рекурсивно обойти первого ребёнка
2. Обработать текущий узел
3. Рекурсивно обойти следующего брата

**Пример:**
```
       1
      / \
     2   3
    / \
   4   5

Post-order: 4 5 2 3 1
```

## Сложность операций

| Операция | Сложность | Комментарий |
|----------|-----------|-------------|
| `create_node` | O(1) | Создание узла |
| `build_from_array` | O(n) | Создание n узлов |
| `first_child` | O(1) | Доступ по указателю |
| `next_sibling` | O(1) | Доступ по указателю |
| `preorder` | O(n) | Посещение каждого узла |
| `postorder` | O(n) | Посещение каждого узла |
| `destroy` | O(n) | Удаление каждого узла |

**Память:** O(n) для дерева + O(h) для рекурсии (h - высота)

## Преимущества и недостатки

### Преимущества ✅
- **Компактность**: всего 2 указателя на узел
- **Гибкость**: любое количество детей
- **Эффективность**: не нужны динамические массивы для детей
- **Универсальность**: подходит для любых деревьев

### Недостатки ❌
- **Доступ к детям**: O(k) для доступа к k-му ребёнку (надо пройти по братьям)
- **Неочевидность**: структура менее интуитивна
- **Обход братьев**: для доступа к последнему ребёнку нужен проход

## Применение общих деревьев

### Файловые системы
```
/
├── home/
│   ├── user1/
│   └── user2/
├── var/
└── etc/
```

### Организационные структуры
```
CEO
├── CTO
│   ├── Dev Team 1
│   └── Dev Team 2
├── CFO
└── COO
```

### XML/HTML документы
```html
<html>
  <head>
    <title>Page</title>
  </head>
  <body>
    <div>Content</div>
  </body>
</html>
```

### Синтаксические деревья
```
        +
       / \
      *   5
     / \
    3   4
```

## Компиляция и запуск

```bash
gcc dyn.c -o gtree
./gtree
```

**Примечание:** Раскомментируйте функцию `main()` перед компиляцией.

## Примеры использования

### Пример 1: Одноуровневое дерево
```c
int values[] = {1, 2, 3, 4, 5};
tree_ov tree = build_from_array(values, 5);

// Структура:
//       1
//     / | \ \
//    2  3  4  5

printf("Pre-order: ");
preorder(tree);    // 1 2 3 4 5

printf("\nPost-order: ");
postorder(tree);   // 2 3 4 5 1

destroy(tree);
```

### Пример 2: Многоуровневое дерево
```c
// Создаём листья
tree_ov leaf1 = create_node(4);
tree_ov leaf2 = create_node(5);

// Создаём узел с детьми
tree_ov children1[] = {leaf1, leaf2};
tree_ov child1 = build(2, children1, 2);

tree_ov child2 = create_node(3);

// Создаём корень
tree_ov children[] = {child1, child2};
tree_ov root = build(1, children, 2);

// Структура:
//       1
//      / \
//     2   3
//    / \
//   4   5

printf("Pre-order: ");
preorder(root);    // 1 2 4 5 3

printf("\nPost-order: ");
postorder(root);   // 4 5 2 3 1

destroy(root);
```

### Пример 3: Навигация по дереву
```c
tree_ov tree = /* ... */;

// Получить первого ребёнка корня
tree_ov child = first_child(tree);
printf("First child: %d\n", root_value(child));

// Получить следующего брата
tree_ov sibling = next_sibling(child);
printf("Next sibling: %d\n", root_value(sibling));
```

## Альтернативные представления

Кроме "первый ребёнок - следующий брат", существуют другие способы:

### 1. Массив указателей на детей
```c
struct node {
    int val;
    node** children;    // Массив указателей
    int num_children;
};
```
**Плюсы:** Прямой доступ к любому ребёнку O(1)
**Минусы:** Дополнительная память, сложность управления

### 2. Список детей
```c
struct node {
    int val;
    List* children;    // Связный список детей
};
```
**Плюсы:** Динамическое количество детей
**Минусы:** Доступ к ребёнку O(k)

### 3. Представление через массив
```c
struct {
    int* values;
    int* parents;      // Индекс родителя для каждого узла
};
```
**Плюсы:** Компактность, cache-friendly
**Минусы:** Сложность навигации

## Ресурсы

- [General Tree - GeeksforGeeks](https://www.geeksforgeeks.org/generic-treesn-array-trees/)
- [Left-child right-sibling representation](https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree)
- [Tree Data Structures](https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html)

