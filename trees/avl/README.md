# AVL-дерево (Сбалансированное дерево поиска)

Самобалансирующееся бинарное дерево поиска, названное в честь изобретателей **Адельсона-Вельского** и **Ландиса** (1962).

## Что такое AVL-дерево?

**AVL-дерево** - это бинарное дерево поиска с автоматической балансировкой, которое гарантирует логарифмическую высоту дерева.

### Ключевые свойства

1. **Свойство BST (Binary Search Tree):**
   - Левое поддерево содержит только узлы с ключами меньше корня
   - Правое поддерево содержит только узлы с ключами больше корня
   - Оба поддерева также являются BST

2. **Свойство AVL-балансировки:**
   - Для каждого узла высоты левого и правого поддеревьев отличаются **не более чем на 1**
   - Разность высот называется **балансом узла** (balance factor)
   - Баланс может быть: **-1, 0, +1**

### Баланс узла

```
balance = height(right) - height(left)

balance = -1:  левое поддерево выше на 1
balance =  0:  поддеревья одинаковой высоты
balance = +1:  правое поддерево выше на 1
```

**Пример сбалансированного дерева:**
```
        10 (balance=0)
       /  \
      5    15 (balance=0)
     / \   / \
    3   7 12  20
   (все балансы -1, 0 или +1)
```

**Пример несбалансированного дерева:**
```
    10 (balance=-2) ← нарушение!
   /
  5 (balance=-1)
 /
3
```

## Основная идея

### Проблема обычного BST

В обычном дереве поиска при неудачной последовательности вставок дерево может **деградировать в список**:

```
Вставляем: 1, 2, 3, 4, 5

    1           O(n) высота!
     \
      2         Поиск: O(n)
       \        Вставка: O(n)
        3       Удаление: O(n)
         \
          4
           \
            5
```

### Решение AVL

AVL-дерево **автоматически балансируется** после каждой операции, гарантируя:
- Высота дерева: **O(log n)**
- Поиск: **O(log n)**
- Вставка: **O(log n)**
- Удаление: **O(log n)**

```
Вставляем: 1, 2, 3, 4, 5 в AVL

      3           O(log n) высота!
     / \
    2   4         Все операции: O(log n)
   /     \
  1       5
```

## Теорема Адельсона-Вельского-Ландиса

**По теореме:** высота AVL-дерева никогда не превышает **1.45 × log(n)**

Это означает, что даже в худшем случае высота дерева остаётся логарифмической.

## Операции балансировки

### Типы вращений

Для восстановления баланса используется **4 типа вращений**:

#### 1. Левое вращение (Left Rotation / LL)
Используется, когда правое поддерево слишком высокое.

```
    A (balance=+2)           B
     \                      / \
      B          =>        A   C
       \
        C

Код: ll_rot(A)
```

#### 2. Правое вращение (Right Rotation / RR)
Используется, когда левое поддерево слишком высокое.

```
        C (balance=-2)     B
       /                  / \
      B        =>        A   C
     /
    A

Код: rr_rot(C)
```

#### 3. Левое-правое вращение (LR)
Используется при "зигзаге" влево-вправо.

```
      A (balance=-2)         A                B
     /                      /                / \
    C        =>            B       =>       C   A
     \                    /
      B                  C

Шаги:
1. ll_rot(C)  - левое вращение на C
2. rr_rot(A)  - правое вращение на A
```

#### 4. Правое-левое вращение (RL)
Используется при "зигзаге" вправо-влево.

```
    A (balance=+2)       A                  B
     \                    \                / \
      C        =>          B      =>      A   C
     /                      \
    B                        C

Шаги:
1. rr_rot(C)  - правое вращение на C
2. ll_rot(A)  - левое вращение на A
```

### Когда какое вращение?

После вставки/удаления проверяем баланс снизу вверх:

| Баланс узла | Баланс ребёнка | Вращение | Случай |
|-------------|----------------|----------|--------|
| +2 | +1 или +2 | Левое (LL) | Правый-правый |
| +2 | -1 | Право-левое (RL) | Правый-левый |
| -2 | -1 или -2 | Правое (RR) | Левый-левый |
| -2 | +1 | Лево-правое (LR) | Левый-правый |

## Функциональная спецификация

### Структуры данных

```c
struct node {
    int val;              // Значение узла
    node* left_son;       // Левый ребёнок
    node* right_son;      // Правый ребёнок
    int height;           // Высота поддерева
};

struct avl_tree {
    int depth;            // Глубина дерева
    node* root;           // Корень дерева
    int node_cnt;         // Количество узлов
};
```

### Базовые операции

#### Поиск
```
search(tree, key) → node | NULL
```
- Вход: дерево, искомый ключ
- Выход: узел с ключом или NULL
- Сложность: **O(log n)**
- Идея: стандартный поиск в BST (идём влево если меньше, вправо если больше)

#### Вставка
```
insert(tree, key) → tree
```
- Вход: дерево, новый ключ
- Выход: обновлённое дерево
- Сложность: **O(log n)**
- Идея:
  1. Вставляем как в обычный BST
  2. Обновляем высоты по пути назад
  3. Проверяем балансы всех узлов на пути
  4. Если баланс нарушен (|balance| > 1) → применяем вращение

#### Удаление
```
delete(tree, key) → tree
```
- Вход: дерево, удаляемый ключ
- Выход: обновлённое дерево
- Сложность: **O(log n)**
- Идея:
  1. Находим узел для удаления
  2. Удаляем по правилам BST:
     - Лист → просто удаляем
     - Один ребёнок → заменяем узел на ребёнка
     - Два ребёнка → заменяем на минимум из правого поддерева
  3. Обновляем высоты и балансируем дерево

#### Вспомогательные операции

```
height(node) → int
```
- Возвращает высоту узла (для NULL возвращает 0)

```
update_height(node)
```
- Пересчитывает высоту: `height = 1 + max(height(left), height(right))`

```
get_balance(node) → int
```
- Возвращает баланс: `balance = height(right) - height(left)`

```
min_node(node) → node
```
- Находит узел с минимальным значением (самый левый)

```
max_node(node) → node
```
- Находит узел с максимальным значением (самый правый)

## Детали реализации вращений

### Левое вращение (ll_rot)

```
Было:                 Стало:
    A                   B
   / \                 / \
  A1  B      =>       A   B2
     / \             / \
    B1 B2           A1 B1

Действия:
1. tmp = A->right_son->left_son  (сохраняем B1)
2. answ = A->left_son            (сохраняем A1)
3. A->left_son = tmp             (B1 становится левым ребёнком A)
4. answ->right_son = A           (A становится правым ребёнком нового корня)
5. Обновляем высоты A, затем answ
```

### Правое вращение (rr_rot)

```
Было:                 Стало:
      C                 B
     / \               / \
    B   C2    =>      B1  C
   / \                   / \
  B1 B2                 B2 C2

Действия:
1. tmp = A->left_son->right_son  (сохраняем B2)
2. answ = A->right_son           (сохраняем C2)
3. A->right_son = tmp            (B2 становится правым ребёнком C)
4. answ->left_son = A            (C становится левым ребёнком нового корня)
5. Обновляем высоты A, затем answ
```

### Комбинированные вращения

**Левое-правое (lr_rot):**
```c
lr_rot(node) {
    node->left_son = ll_rot(node->left_son);
    return rr_rot(node);
}
```

**Правое-левое (rl_rot):**
```c
rl_rot(node) {
    node->right_son = rr_rot(node->right_son);
    return ll_rot(node);
}
```

## Алгоритм вставки

### Псевдокод

```
insert(node, key):
    // 1. Стандартная вставка BST
    if node == NULL:
        return create_node(key)
    
    if key < node->val:
        node->left = insert(node->left, key)
    else if key > node->val:
        node->right = insert(node->right, key)
    else:
        return node  // дубликаты не допускаются
    
    // 2. Обновляем высоту текущего узла
    update_height(node)
    
    // 3. Получаем баланс
    balance = get_balance(node)
    
    // 4. Если нарушен баланс, применяем вращение
    
    // Левый-левый случай (balance < -1, вставили в левое-левое)
    if balance < -1 and key < node->left->val:
        return rr_rot(node)
    
    // Правый-правый случай (balance > +1, вставили в правое-правое)
    if balance > +1 and key > node->right->val:
        return ll_rot(node)
    
    // Левый-правый случай (balance < -1, вставили в левое-правое)
    if balance < -1 and key > node->left->val:
        return lr_rot(node)
    
    // Правый-левый случай (balance > +1, вставили в правое-левое)
    if balance > +1 and key < node->right->val:
        return rl_rot(node)
    
    return node
```

### Пример пошаговой вставки

**Вставим: 1, 2, 3**

```
Шаг 1: вставка 1
    1 (balance=0)

Шаг 2: вставка 2
    1 (balance=+1)
     \
      2 (balance=0)

Шаг 3: вставка 3
    1 (balance=+2) ← нарушение!
     \
      2 (balance=+1)
       \
        3

Правый-правый случай → левое вращение ll_rot(1):

      2 (balance=0)
     / \
    1   3
```

## Алгоритм удаления

### Псевдокод

```
delete(node, key):
    // 1. Стандартное удаление BST
    if node == NULL:
        return NULL
    
    if key < node->val:
        node->left = delete(node->left, key)
    else if key > node->val:
        node->right = delete(node->right, key)
    else:
        // Узел найден - удаляем
        if node->left == NULL:
            return node->right
        else if node->right == NULL:
            return node->left
        else:
            // Два ребёнка: заменяем на минимум из правого
            min_node = find_min(node->right)
            node->val = min_node->val
            node->right = delete(node->right, min_node->val)
    
    // 2. Обновляем высоту
    update_height(node)
    
    // 3. Получаем баланс
    balance = get_balance(node)
    
    // 4. Балансируем если нужно
    
    // Левый-левый
    if balance < -1 and get_balance(node->left) <= 0:
        return rr_rot(node)
    
    // Левый-правый
    if balance < -1 and get_balance(node->left) > 0:
        return lr_rot(node)
    
    // Правый-правый
    if balance > +1 and get_balance(node->right) >= 0:
        return ll_rot(node)
    
    // Правый-левый
    if balance > +1 and get_balance(node->right) < 0:
        return rl_rot(node)
    
    return node
```

### Важный момент при удалении

При удалении узла с двумя детьми **критически важно** правильно выбрать узел для замены:

**Вариант 1:** Минимум из правого поддерева (самый левый узел справа)
**Вариант 2:** Максимум из левого поддерева (самый правый узел слева)

Оба варианта корректны и сохраняют свойство BST.

### Особенность балансировки при удалении

При удалении может потребоваться **несколько балансировок** вверх по дереву (в отличие от вставки, где достаточно одной). Это происходит потому, что удаление может уменьшить высоту поддерева на 1, что повлияет на балансы предков.

## Сложность операций

| Операция | Сложность | Комментарий |
|----------|-----------|-------------|
| Поиск | **O(log n)** | Высота дерева логарифмическая |
| Вставка | **O(log n)** | Поиск + балансировка |
| Удаление | **O(log n)** | Поиск + удаление + балансировка |
| Минимум/Максимум | **O(log n)** | Идём до конца влево/вправо |
| Обход (in-order) | **O(n)** | Посещаем каждый узел |

**Память:** O(n) для хранения узлов + O(log n) для стека рекурсии

## Преимущества AVL-дерева

✅ **Гарантированная производительность** - все операции O(log n) в худшем случае
✅ **Строгая балансировка** - высота минимальна (±1 для всех узлов)
✅ **Быстрый поиск** - идеально для приложений с частым поиском
✅ **Предсказуемость** - нет деградации в худшем случае

## Недостатки AVL-дерева

❌ **Частые балансировки** - при вставке/удалении может потребоваться до log(n) вращений
❌ **Сложность реализации** - больше кода, чем для обычного BST
❌ **Накладные расходы** - нужно хранить высоту (или баланс) в каждом узле
❌ **Вставка медленнее** - чем у красно-чёрного дерева (больше вращений)

## Сравнение с другими структурами

### AVL vs Красно-чёрное дерево

| Характеристика | AVL | Red-Black |
|----------------|-----|-----------|
| Балансировка | Строже (±1) | Мягче (соотношение высот ≤2) |
| Поиск | Быстрее | Медленнее |
| Вставка | Медленнее (больше вращений) | Быстрее |
| Удаление | Медленнее | Быстрее |
| Применение | Много чтения | Много записи |

### AVL vs Обычный BST

| Характеристика | AVL | BST |
|----------------|-----|-----|
| Худший случай | O(log n) | O(n) |
| Балансировка | Автоматическая | Нет |
| Память | +O(1) на узел (высота) | Меньше |
| Реализация | Сложнее | Проще |

### AVL vs B-дерево

| Характеристика | AVL | B-tree |
|----------------|-----|--------|
| Дети в узле | 2 | Много (100+) |
| Применение | Память | Диск |
| Высота | log₂(n) | logₘ(n) (m>>2) |
| Локальность | Хуже | Лучше |

## Применение AVL-деревьев

### Где используется?

1. **Базы данных** - индексы для быстрого поиска
2. **Файловые системы** - организация файлов
3. **Словари и множества** - реализация set/map
4. **Графические системы** - пространственные индексы
5. **Маршрутизаторы** - таблицы маршрутизации

### Когда использовать AVL?

**Используйте AVL когда:**
- ✅ Много операций поиска
- ✅ Нужна гарантированная производительность
- ✅ Важна минимальная высота дерева
- ✅ Вставок/удалений относительно немного

**Не используйте AVL когда:**
- ❌ Много вставок/удалений (используйте Red-Black)
- ❌ Данные на диске (используйте B-tree)
- ❌ Нужна простота (используйте обычный BST или hash-table)

## Интересные факты

1. **Худший случай:** AVL-дерево в худшем случае имеет структуру чисел Фибоначчи
   ```
   Минимальное AVL-дерево высоты h имеет F(h+3)-1 узлов,
   где F(n) - числа Фибоначчи
   ```

2. **Количество вращений:**
   - Вставка: максимум **2 вращения**
   - Удаление: максимум **O(log n) вращений** (по пути к корню)

3. **Изобретение:** AVL-дерево было первой самобалансирующейся структурой данных (1962)

4. **Высота:** Для n узлов высота AVL-дерева не превышает **1.44 × log₂(n + 2)**

## Варианты хранения баланса

### Вариант 1: Хранение высоты
```c
struct node {
    int height;  // Высота поддерева
};
// balance = height(right) - height(left)
```
**Плюсы:** Легко вычислять баланс
**Минусы:** Нужно обновлять высоту при каждом изменении

### Вариант 2: Хранение баланса
```c
struct node {
    int balance;  // -1, 0, +1
};
```
**Плюсы:** Меньше памяти (можно использовать 2 бита)
**Минусы:** Сложнее обновлять при вращениях

## Резюме

**AVL-дерево** - это элегантная и эффективная структура данных, которая гарантирует логарифмическую сложность всех основных операций благодаря автоматической балансировке через вращения.

**Ключевые моменты:**
- Баланс каждого узла: -1, 0, +1
- Вращения восстанавливают баланс за O(1)
- Все операции: O(log n)
- Идеально для приложений с частым поиском

**Следующий шаг:** Реализация на языке C с примерами использования.

## Ресурсы

- [AVL Tree - Wikipedia](https://ru.wikipedia.org/wiki/АВЛ-дерево)
- [AVL Tree Visualizer](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)
- [Balanced Trees - GeeksforGeeks](https://www.geeksforgeeks.org/avl-tree-set-1-insertion/)

